<#@ template language="C#" debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ include file="EF.Utility.CS.ttinclude" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#
    CodeGenerationTools code = new CodeGenerationTools(this);
    MetadataLoader loader = new MetadataLoader(this);
    CodeRegion region = new CodeRegion(this, 1);
    MetadataTools ef = new MetadataTools(this);

    string inputFile = @"..\VirtualTFS.edmx";
    EdmItemCollection ItemCollection = loader.CreateEdmItemCollection(inputFile);
    string namespaceName = code.VsNamespaceSuggestion();

    EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);

    // Emit Entity Types
    foreach (EntityType entity in ItemCollection.GetItems<EntityType>().OrderBy(e => e.Name))
    {
        string filename = entity.Name + "Model.cs";
        // Write out support code to primary template output file
        fileManager.StartNewFile(filename);
        WriteHeader(fileManager);
        BeginNamespace(namespaceName, code);
        BeginBodyClass(entity, code, region);
        if(!DoesFileExist(filename))
        {
            EndBodyClass();
            EndNamespace(namespaceName);
        }
        //break;
    }
    fileManager.Process();
#>

<#+
    void WriteHeader(EntityFrameworkTemplateFileManager fileManager, params string[] extraUsings)
    {
        //fileManager.StartHeader();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using VirtualTFS.DAL;

<#+
        //String.Join(String.Empty, extraUsings.Select(u => "using " + u + ";" + Environment.NewLine).ToArray());
        //fileManager.EndBlock();
    }
#>

<#+
    void BeginNamespace(string namespaceName, CodeGenerationTools code)
    {
        CodeRegion region = new CodeRegion(this);
        if (!String.IsNullOrEmpty(namespaceName))
        {
#>
namespace <#=
            code.EscapeNamespace(namespaceName)
            #>
{
<#+
            PushIndent(CodeRegion.GetIndent(1));
        }
    }
#>

<#+
    void EndNamespace(string namespaceName)
    {
        if (!String.IsNullOrEmpty(namespaceName))
        {
            PopIndent();
#>
}
<#+
        }
    }
#>

<#+
    void BeginBodyClass(EntityType entity, CodeGenerationTools code, CodeRegion region)
    {
        string customCode = string.Empty;
        string filename = entity.Name + "Model.cs";
        if(DoesFileExist(filename))
            customCode = OutputCustomCode(filename);
#>
/// <summary>
/// Model for table <#=        code.Escape(entity.Name)#> 
/// </summary>
<#=        Accessibility.ForType(entity)#> <#=        code.SpaceAfter(code.AbstractOption(entity))#>partial class <#=        code.Escape(entity.Name + "Model")#> <#=        code.StringBefore(": ", code.Escape(entity.BaseType))#>
{
<#+
        region.Begin("Ctor");
        this.WriteLine(string.Empty);
        PushIndent(CodeRegion.GetIndent(1));
        #>
// Default contructor
public <#=        code.Escape(entity.Name + "Model")#>()
{
    this.IsNewItem = true;
    this.<#=        ToLowercaseNamingConvention(code.Escape(entity.Name))#> = new <#=        code.Escape(entity.Name)#>();
}
<#+        this.WriteLine(string.Empty);#>
// Default contructor that set entity to field
public <#=        code.Escape(entity.Name + "Model")#>(<#=        code.Escape(entity.Name)#> <#=        code.Escape(entity.Name).ToLower()#>)
{
	this.<#=        ToLowercaseNamingConvention(code.Escape(entity.Name))#> = <#=        code.Escape(entity.Name).ToLower()#>;
<#+	foreach (EdmProperty edmProperty in entity.Properties.Where(p => p.TypeUsage.EdmType is PrimitiveType && p.DeclaringType == entity))
        {
#>
    this.<#=            ToLowercaseNamingConvention(code.Escape(edmProperty))#> = <#=        code.Escape(entity.Name).ToLower()#>.<#=            code.Escape(edmProperty)#>;
<#+
		}
#>
    this._original<#=        code.Escape(entity.Name)#> = <#=        code.Escape(entity.Name).ToLower()#>.DeepClone();
}
<#+
        PopIndent();
        region.End();
        this.WriteLine(string.Empty);
        region.Begin("Entity Properties");
        PushIndent(CodeRegion.GetIndent(1));
        this.WriteLine(string.Empty);
#>

public event EventHandler PropertyChanged;
private <#=        code.Escape(entity.Name)#> <#=        ToLowercaseNamingConvention(code.Escape(entity.Name))#>;
private <#=        code.Escape(entity.Name)#> _original<#=        code.Escape(entity.Name)#>;

public <#=        code.Escape(entity.Name)#> Map<#=        code.Escape(entity.Name)#>()
{
<#+	foreach (EdmProperty edmProperty in entity.Properties.Where(p => p.TypeUsage.EdmType is PrimitiveType && p.DeclaringType == entity))
        {
#>
    this.<#=        ToLowercaseNamingConvention(code.Escape(entity.Name))#>.<#=            code.Escape(edmProperty)#> = this.<#=            ToLowercaseNamingConvention(code.Escape(edmProperty))#>;
<#+
		}
#>
	return <#=        ToLowercaseNamingConvention(code.Escape(entity.Name))#>;
}

public void Undo()
{
    if(this._original<#=        code.Escape(entity.Name)#> == null) return;
<#+	foreach (EdmProperty edmProperty in entity.Properties.Where(p => p.TypeUsage.EdmType is PrimitiveType && p.DeclaringType == entity))
        {
#>
    this.<#=            ToLowercaseNamingConvention(code.Escape(edmProperty))#> = this._original<#=        code.Escape(entity.Name)#>.<#=            code.Escape(edmProperty)#>;
<#+
		}
#>
	this.Commit();
}

public void Reload()
{
	if(this._original<#=        code.Escape(entity.Name)#> == null) return;
<#+	foreach (EdmProperty edmProperty in entity.Properties.Where(p => p.TypeUsage.EdmType is PrimitiveType && p.DeclaringType == entity))
        {
#>
    this.<#=        ToLowercaseNamingConvention(code.Escape(entity.Name))#>.<#=            code.Escape(edmProperty)#> = this._original<#=        code.Escape(entity.Name)#>.<#=            code.Escape(edmProperty)#>;
<#+
		}
#>
}

<#+        this.WriteLine(string.Empty);#>
public bool IsNewItem { get; private set; }
public bool IsDeleted { get; set; }
public bool IsChecked { get; set; }

private bool _isDirty;
public bool IsDirty
{
    get
    {
        return _isDirty;
    }
    private set
    {
        if (_isDirty != value)
        {
            _isDirty = value;
            if (PropertyChanged != null)
                PropertyChanged.Invoke(this, new EventArgs());
        }
    }
}

public void Commit() {
	IsNewItem = false;
	IsDirty = false;
}
<#+
        PopIndent();
        region.End();
        this.WriteLine(string.Empty);
        region.Begin("Primitive Properties");
        PushIndent(CodeRegion.GetIndent(1));
        this.WriteLine(string.Empty);
        foreach (EdmProperty edmProperty in entity.Properties.Where(p => p.TypeUsage.EdmType is PrimitiveType && p.DeclaringType == entity))
        {
#>

private <#=            code.Escape(edmProperty.TypeUsage)#> <#=            ToLowercaseNamingConvention(code.Escape(edmProperty))#>;
<#=            Accessibility.ForProperty(edmProperty)#> <#=            code.Escape(edmProperty.TypeUsage)#> <#=            code.Escape(edmProperty)#>
{
    <#=            code.SpaceAfter(Accessibility.ForGetter(edmProperty))#>get { return this.<#=            ToLowercaseNamingConvention(code.Escape(edmProperty))#>; }
    <#=            code.SpaceAfter(Accessibility.ForSetter(edmProperty))#>set
    {
        if (this.<#=            ToLowercaseNamingConvention(code.Escape(edmProperty))#> != value)
        {
            this.IsDirty = true;
            this.<#=            ToLowercaseNamingConvention(code.Escape(edmProperty))#> = value;
        }
    }
}
<#+
        }
        PopIndent();
        region.End();
        this.WriteLine(string.Empty);
        if(DoesFileExist(entity.Name + "Model.cs"))
        {
            PopIndent();
            PopIndent();
            this.Write(customCode);
        }
        else
        {
            region.Begin("all the custom code");
            this.WriteLine(string.Empty);
            region.End();
        }
    }
#>

<#+
    void EndBodyClass()
    {
#>
}
<#+
    }
#>

<#+
    bool DoesFileExist(string filename)
    {			
        return File.Exists(Path.Combine(GetCurrentDirectory(),filename));
    }
    
    string GetCurrentDirectory()
    {
        string executingDirectoryName = "";
        string stackTraceFileName = new StackTrace(true).GetFrame(0).GetFileName();
        if(String.IsNullOrEmpty(stackTraceFileName))
        {
            throw new ArgumentException("No value was specified for the 'directoryName' configuration parameter" +
                ", and we could not figure out the file name from the stack trace (most likely because of running " +
                "the template with debug='False' specified in the <\u0023@ template \u0023> directive.");
        }
        else
        {		
            executingDirectoryName = Path.GetDirectoryName(stackTraceFileName);
        }	
        return executingDirectoryName;
    }
    
    string OutputCustomCode(string filename)
    {
        using (StreamReader sr = new StreamReader(Path.Combine(GetCurrentDirectory(), filename)))
        {
            string textCustomRegion = "#region all the custom code";
            string line = string.Empty;
            string contents = string.Empty;
            while ((line = sr.ReadLine()) != null)
            {
                if (line.Contains(textCustomRegion))
                    contents = line + Environment.NewLine + sr.ReadToEnd();
            }
            return contents;
        }
    }

	string ToLowercaseNamingConvention(string s)
    {
            var r = new Regex(@"
                (?<=[A-Z])(?=[A-Z][a-z]) |
                 (?<=[^A-Z])(?=[A-Z]) |
                 (?<=[A-Za-z])(?=[^A-Za-z])", RegexOptions.IgnorePatternWhitespace);

            return "_" + r.Replace(s, "_").ToLower();
    }
#>